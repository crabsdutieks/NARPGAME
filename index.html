<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>$NARPE ‚Äî Swim & Dodge</title>
<meta name="theme-color" content="#6a00ff" />
<style>
  :root{ --violet:#6a00ff; --night:#001f4d; --teal:#16c7be; --gold:#ffd75e; --glass:rgba(255,255,255,.08)}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:linear-gradient(180deg,var(--violet),var(--night));color:#fff;font-family:system-ui,-apple-system,Inter,Segoe UI,Roboto,Arial,sans-serif;overflow:hidden}
  #canvas{display:block;width:100vw;height:100vh}
  /* HUD */
  #hud{position:fixed;inset:0;pointer-events:none;display:flex;flex-direction:column;justify-content:space-between;padding:env(safe-area-inset-top) 14px env(safe-area-inset-bottom) 14px}
  .row{display:flex;align-items:center;justify-content:space-between;gap:10px}
  .pill{background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.16);padding:8px 12px;border-radius:12px;backdrop-filter:blur(6px);font-weight:800;letter-spacing:.3px}
  .btn{pointer-events:auto;user-select:none;cursor:pointer;background:var(--teal);color:#081018;border:none;font-weight:900;padding:10px 14px;border-radius:12px;box-shadow:0 6px 0 rgba(0,0,0,.35);transition:transform .06s ease,filter .2s ease}
  .btn:active{transform:translateY(2px);box-shadow:0 4px 0 rgba(0,0,0,.35)}
  .btn.alt{background:#fff;color:#111}
  .btn.gold{background:var(--gold);color:#111}
  /* Overlays */
  #overlay{position:fixed;inset:0;display:none;place-items:center;background:rgba(0,0,0,.38);backdrop-filter:blur(6px);z-index:5}
  #overlay.show{display:grid}
  .card{width:min(560px,92vw);background:linear-gradient(180deg,var(--glass),rgba(255,255,255,.05));border:1px solid rgba(255,255,255,.16);border-radius:18px;padding:20px;text-align:center}
  h1{margin:.2rem 0 0;font-size:1.6rem}
  p{margin:.35rem 0;opacity:.92}
  .hint{font-size:.9rem;opacity:.85}
  .actions{display:flex;gap:10px;justify-content:center;margin-top:12px}
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<!-- HUD -->
<div id="hud">
  <div class="row" style="padding:10px">
    <div class="pill" id="score">Score: 0</div>
    <div class="row" style="gap:8px">
      <div class="pill" id="coins">Coins: 0</div>
      <div class="pill" id="best">Best: 0</div>
      <button id="muteBtn" class="btn alt">Mute</button>
      <button id="pauseBtn" class="btn">Pause</button>
    </div>
  </div>
  <div class="row" style="padding:10px">
    <a class="btn gold" href="/" title="Back to site">‚Üê Back</a>
    <button id="restartBtn" class="btn">Restart</button>
  </div>
</div>

<!-- Start / Game Over overlay -->
<div id="overlay" class="show" role="dialog" aria-modal="true">
  <div class="card">
    <h1 id="title">$NARPE ‚Äî Swim & Dodge</h1>
    <p id="subtitle">Tap / Space / ‚Üë to swim. Avoid obstacles, collect coins, and ride the current.</p>
    <p class="hint">Mobile: tap anywhere ¬∑ Desktop: Space or ‚Üë ¬∑ M to mute</p>
    <div class="actions">
      <button id="playBtn" class="btn">Play</button>
      <button id="howBtn" class="btn alt">How to</button>
    </div>
    <div class="actions" id="shareWrap" style="display:none">
      <button id="shareBtn" class="btn gold">Share score on X</button>
    </div>
  </div>
</div>

<script>
(()=>{
/* ================== Canvas & DPI ================== */
const dpr = Math.max(1, Math.min(2, devicePixelRatio||1));
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
function resize(){ canvas.width = Math.floor(innerWidth*dpr); canvas.height = Math.floor(innerHeight*dpr); ctx.setTransform(dpr,0,0,dpr,0,0); }
addEventListener('resize', resize, {passive:true}); resize();

/* ================== Optional Narpe image ================== */
const narpeImg = new Image(); let narpeReady=false;
narpeImg.onload = ()=> narpeReady=true;
narpeImg.onerror = ()=> narpeReady=false;
narpeImg.src = 'narpe.png'; // optional; falls back to drawn narwhal

/* ================== Audio (Web Audio API) ================== */
let audioCtx, masterGain; let muted=false;
function initAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  masterGain = audioCtx.createGain(); masterGain.gain.value = 0.7; masterGain.connect(audioCtx.destination);
  startMusic();
}
function startMusic(){
  // simple chill arpeggio loop
  const o1 = audioCtx.createOscillator(); const g1 = audioCtx.createGain();
  o1.type='sine'; o1.frequency.value = 261.63; // C4
  g1.gain.value = 0.0; o1.connect(g1).connect(masterGain); o1.start();
  // step sequencer
  const notes = [261.63, 293.66, 329.63, 392.00, 329.63, 293.66, 261.63, 196.00]; // simple loop
  let idx = 0;
  setInterval(()=>{
    if(!audioCtx || muted) return;
    const t = audioCtx.currentTime;
    o1.frequency.setTargetAtTime(notes[idx%notes.length], t, 0.02);
    g1.gain.cancelScheduledValues(t); g1.gain.setValueAtTime(0.0, t);
    g1.gain.linearRampToValueAtTime(0.08, t+0.02);
    g1.gain.exponentialRampToValueAtTime(0.0001, t+0.35);
    idx++;
  }, 420);
}
function sfxCoin(){
  if(!audioCtx||muted) return;
  const o = audioCtx.createOscillator(), g = audioCtx.createGain();
  o.type='triangle'; o.frequency.value=800; g.gain.value=0; o.connect(g).connect(masterGain);
  const t=audioCtx.currentTime;
  o.start(t);
  o.frequency.exponentialRampToValueAtTime(1400, t+0.08);
  g.gain.linearRampToValueAtTime(0.18, t+0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, t+0.22);
  o.stop(t+0.24);
}
function sfxLose(){
  if(!audioCtx||muted) return;
  const o = audioCtx.createOscillator(), g = audioCtx.createGain();
  o.type='sawtooth'; o.frequency.value=400; g.gain.value=0; o.connect(g).connect(masterGain);
  const t=audioCtx.currentTime;
  o.start(t);
  o.frequency.exponentialRampToValueAtTime(120, t+0.4);
  g.gain.linearRampToValueAtTime(0.22, t+0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, t+0.5);
  o.stop(t+0.52);
}

/* ================== Game State ================== */
let running=false, paused=false, over=false;
let tLast=0, time=0;
let score=0, coins=0, best = Number(localStorage.getItem('narpe_best')||0);
let speed = 160;             // base speed
let speedMultiplier = 1.0;   // ramps up slowly over time
const SPEED_RAMP = 0.015;    // gentle ramp per second

const HUD = {
  score: document.getElementById('score'),
  coins: document.getElementById('coins'),
  best: document.getElementById('best'),
  pauseBtn: document.getElementById('pauseBtn'),
  restartBtn: document.getElementById('restartBtn'),
  muteBtn: document.getElementById('muteBtn'),
  overlay: document.getElementById('overlay'),
  title: document.getElementById('title'),
  subtitle: document.getElementById('subtitle'),
  playBtn: document.getElementById('playBtn'),
  howBtn: document.getElementById('howBtn'),
  shareWrap: document.getElementById('shareWrap'),
  shareBtn: document.getElementById('shareBtn'),
};
HUD.best.textContent = 'Best: '+best;

const narpe = { x: innerWidth*0.24, y: innerHeight*0.5, vy:0, r:32, tilt:0 }; // r smaller for forgiving hitbox
const OBS = []; // obstacles
const COINS = [];

let spawnTimer=0;
let laneTargetY = innerHeight*0.5; // for smoother, varied paths

/* ================== Helpers ================== */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const rnd=(a,b)=>a+Math.random()*(b-a);
function circleRectHit(cx,cy,cr, rx,ry,rw,rh, margin=6){
  // shrink obstacle rect by a margin to make it less punishing
  const x1=rx+margin, y1=ry+margin, x2=rx+rw-margin, y2=ry+rh-margin;
  const nx=clamp(cx, x1, x2), ny=clamp(cy, y1, y2);
  const dx=cx-nx, dy=cy-ny; return dx*dx+dy*dy < cr*cr;
}

/* ================== Input ================== */
function swim(){
  if(!running){ start(); return; }
  if(over||paused) return;
  narpe.vy = -460; // gentle
}
addEventListener('keydown',e=>{
  if([' ','ArrowUp','Spacebar'].includes(e.key)){ e.preventDefault(); swim(); }
  if(e.key==='p') togglePause();
  if(e.key==='m') toggleMute();
});
addEventListener('pointerdown',()=>swim(),{passive:true});

HUD.playBtn.onclick = ()=> start();
HUD.howBtn.onclick = ()=> HUD.subtitle.textContent = 'Swim with tap/Space. Score = distance (+1 per gate). Coins = +5 and build your total. Game slowly speeds up.';
HUD.pauseBtn.onclick = ()=> togglePause();
HUD.restartBtn.onclick = ()=> reset(true);
HUD.muteBtn.onclick = ()=> toggleMute();
HUD.shareBtn.onclick = ()=>{
  const text = encodeURIComponent(`I scored ${score} (and ${coins} coins) in the $NARPE Swim & Dodge mini-game! üåäü¶Ñ #NARPE #Abstract`);
  const url = encodeURIComponent(location.origin);
  window.open(`https://twitter.com/intent/tweet?text=${text}&url=${url}`, '_blank');
};

function togglePause(){
  if(!running||over) return;
  paused=!paused; HUD.pauseBtn.textContent = paused? 'Resume':'Pause';
  showOverlay(paused, paused? 'Paused' : '', paused? 'Tap / Space / ‚Üë to continue.' : '');
}

function toggleMute(){
  muted = !muted;
  HUD.muteBtn.textContent = muted ? 'Unmute' : 'Mute';
  if(audioCtx){
    masterGain.gain.value = muted ? 0 : 0.7;
  }
}

/* ================== Flow ================== */
function showOverlay(show, title, subtitle){
  HUD.overlay.classList.toggle('show', !!show);
  if(title!==undefined && title!=='') HUD.title.textContent = title;
  if(subtitle!==undefined && subtitle!=='') HUD.subtitle.textContent = subtitle;
  HUD.shareWrap.style.display = (show && over) ? 'flex' : 'none';
}
function start(){
  reset(false);
  running=true; paused=false; over=false;
  tLast=performance.now();
  showOverlay(false);
  initAudio();
  requestAnimationFrame(loop);
}
function reset(hard){
  score=0; coins=0; speed=160; speedMultiplier=1.0;
  HUD.score.textContent='Score: 0'; HUD.coins.textContent='Coins: 0';
  narpe.x=innerWidth*0.24; narpe.y=innerHeight*0.5; narpe.vy=0; narpe.tilt=0;
  OBS.length=0; COINS.length=0; spawnTimer=0;
  laneTargetY = innerHeight*0.5;
  if(hard){ running=false; over=false; paused=false; showOverlay(true,'$NARPE ‚Äî Swim & Dodge','Tap / Space / ‚Üë to swim. Avoid obstacles, collect coins, and ride the current.'); }
}
function end(){
  over=true; running=false; paused=false;
  if(score>best){ best=score; localStorage.setItem('narpe_best',best); HUD.best.textContent='Best: '+best; }
  sfxLose();
  showOverlay(true, 'Game Over', `Score: ${score} ‚Ä¢ Best: ${best} ‚Ä¢ Coins: ${coins}`);
  HUD.shareWrap.style.display='flex';
}

/* ================== Spawning (varied & forgiving) ================== */
function spawn(){
  // Keep gaps relatively wide; vary center smoothly
  const GAP = 210; // fixed-ish gap (forgiving)
  // Smoothly move laneTargetY up/down, then clamp
  laneTargetY += rnd(-120,120);
  laneTargetY = clamp(laneTargetY, innerHeight*0.28, innerHeight*0.72);

  const yMid = laneTargetY;
  const v = speed * speedMultiplier;

  // Mix of ice/mine, but keep shapes simple and visible
  const typeTop = Math.random()<0.75? 'ice':'mine';
  const typeBot = Math.random()<0.65? 'ice':'mine';

  OBS.push({x: innerWidth+60, y: yMid-GAP/2-170, w:60, h:270, vx:-v, type:typeTop, passed:false});
  OBS.push({x: innerWidth+60, y: yMid+GAP/2,   w:60, h:270, vx:-v, type:typeBot, passed:false});

  // Coin appears in the gap line most of the time (visible, fair)
  if(Math.random()<0.8){
    COINS.push({x: innerWidth+ 60 + rnd(140,200), y: yMid + rnd(-GAP/3, GAP/3), r:12, vx:-v, got:false});
  }

  // next spawn based on speed (consistent spacing)
  const baseInterval = 1.6; // seconds
  spawnTimer = baseInterval * (160 / speed); // more speed => shorter interval
}

/* ================== Drawing ================== */
function drawBG(tm){
  const w=innerWidth,h=innerHeight;
  ctx.clearRect(0,0,w,h);
  const g = ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0,'#0a2a6b'); g.addColorStop(1,'#041632');
  ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
  // rays
  for(let i=0;i<5;i++){
    const x = (tm*0.02 + i*220)%(w+220)-220;
    ctx.globalAlpha=.06; ctx.fillStyle='#7fd1ff';
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x+140,0); ctx.lineTo(x+40,h); ctx.lineTo(x-100,h); ctx.closePath(); ctx.fill();
  }
  ctx.globalAlpha=1;
  // bubbles
  for(let i=0;i<18;i++){
    const bx=(tm*0.12 + i*(w/18))%(w+80)-40;
    const by=(tm*0.06 + i*40)%(h+40)-20;
    ctx.globalAlpha=.35; ctx.fillStyle='#b8f0ff';
    ctx.beginPath(); ctx.arc(bx,h-by,3+(i%3),0,Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha=1;
}
function drawNarpe(x,y,tilt){
  if(narpeReady){
    const s=96; ctx.save(); ctx.translate(x,y); ctx.rotate(tilt*0.04);
    ctx.drawImage(narpeImg,-s*0.6,-s*0.6,s*1.2,s*1.2); ctx.restore();
  }else{
    ctx.save(); ctx.translate(x,y); ctx.rotate(tilt*0.04);
    ctx.fillStyle='#bfe7ff'; ctx.beginPath(); ctx.ellipse(0,0,44,34,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#e8f7ff'; ctx.beginPath(); ctx.ellipse(0,8,26,20,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#bfe7ff'; ctx.beginPath(); ctx.moveTo(-40,8); ctx.quadraticCurveTo(-64,0,-44,-8); ctx.quadraticCurveTo(-28,0,-40,8); ctx.fill();
    ctx.strokeStyle='#503200'; ctx.lineWidth=2; ctx.fillStyle='#ffd75e';
    ctx.beginPath(); ctx.moveTo(22,-18); ctx.lineTo(58,-28); ctx.lineTo(20,-8); ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.fillStyle='#fff'; ctx.beginPath(); ctx.ellipse(8,-4,12,10,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(12,-4,4,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#ed6a5a'; ctx.lineWidth=4; ctx.beginPath(); ctx.arc(6,10,12,.2*Math.PI,.9*Math.PI); ctx.stroke();
    ctx.restore();
  }
}
function drawObstacle(o){
  ctx.save(); ctx.translate(o.x,o.y);
  if(o.type==='ice'){
    ctx.fillStyle='#9fe3ff'; ctx.strokeStyle='#4aa7c7'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(o.w,10); ctx.lineTo(o.w,o.h); ctx.lineTo(0,o.h); ctx.closePath(); ctx.fill(); ctx.stroke();
  }else{
    ctx.fillStyle='#5c6b7a'; ctx.beginPath(); ctx.arc(o.w*0.5,o.h*0.5,24,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#7f8fa0';
    for(let k=0;k<6;k++){ const a=k*Math.PI/3,R=34; ctx.beginPath(); ctx.arc(o.w*0.5+Math.cos(a)*R,o.h*0.5+Math.sin(a)*R,4,0,Math.PI*2); ctx.fill(); }
  }
  ctx.restore();
}
function drawCoin(c){
  ctx.save(); ctx.translate(c.x,c.y);
  const r=c.r, g=ctx.createRadialGradient(0,0,2,0,0,r);
  g.addColorStop(0,'#fff5cc'); g.addColorStop(1,'#ffd75e');
  ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='rgba(0,0,0,.35)'; ctx.lineWidth=2; ctx.stroke();
  ctx.restore();
}

/* ================== Loop ================== */
function loop(now){
  if(!running) return;
  const dt=Math.min(0.04,(now-tLast)/1000); tLast=now; time+=dt;

  if(!paused && !over){
    // ramp speed (not gap): very gradual
    speedMultiplier += SPEED_RAMP * dt; // tiny increase per frame
    const v = speed * speedMultiplier;

    // physics
    const G = 1100; // gravity
    narpe.vy += G*dt; narpe.vy = clamp(narpe.vy, -520, 700);
    narpe.y += narpe.vy*dt; narpe.y = clamp(narpe.y, 30, innerHeight-30);
    narpe.tilt = narpe.vy / 200;

    // spawn cadence tied to speed
    spawnTimer -= dt;
    if(spawnTimer<=0) spawn();

    // move
    for(const o of OBS){ o.vx = -v; o.x += o.vx*dt; }
    for(const c of COINS){ c.vx = -v; c.x += c.vx*dt; }

    // collisions (forgiving: smaller r + obstacle margin)
    for(const o of OBS){
      if(circleRectHit(narpe.x,narpe.y,narpe.r, o.x,o.y,o.w,o.h, 8)){ end(); return; }
      if(!o.passed && o.x+o.w < narpe.x){ o.passed=true; score+=1; HUD.score.textContent='Score: '+score; }
    }
    for(const c of COINS){
      if(!c.got && ((narpe.x-c.x)**2 + (narpe.y-c.y)**2) < (narpe.r*0.75 + c.r)**2){
        c.got=true; coins++; score+=5; HUD.coins.textContent='Coins: '+coins; HUD.score.textContent='Score: '+score; sfxCoin();
      }
    }

    // cleanup
    while(OBS.length && OBS[0].x + OBS[0].w < -100) OBS.shift();
    while(COINS.length && COINS[0].x < -100) COINS.shift();
  }

  // draw
  drawBG(time*60);
  for(const o of OBS) drawObstacle(o);
  for(const c of COINS) if(!c.got) drawCoin(c);
  drawNarpe(narpe.x,narpe.y,narpe.tilt);

  requestAnimationFrame(loop);
}

/* ================== Start overlay ================== */
showOverlay(true);
HUD.title.textContent = '$NARPE ‚Äî Swim & Dodge';
HUD.subtitle.textContent = 'Tap / Space / ‚Üë to swim. Avoid obstacles, collect coins, and ride the current.';
})();
</script>
</body>
</html>
