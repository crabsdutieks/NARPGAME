<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>$NARPE ‚Äî Swim & Dodge</title>
<meta name="theme-color" content="#6a00ff" />
<style>
  :root{ --violet:#6a00ff; --night:#001f4d; --teal:#16c7be; --gold:#ffd75e; --glass:rgba(255,255,255,.08) }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:linear-gradient(180deg,var(--violet),var(--night));color:#fff;font-family:system-ui,-apple-system,Inter,Segoe UI,Roboto,Arial,sans-serif;overflow:hidden}
  #canvas{display:block;width:100vw;height:100vh}
  /* HUD */
  #hud{position:fixed;inset:0;pointer-events:none;display:flex;flex-direction:column;justify-content:space-between;padding:env(safe-area-inset-top) 14px env(safe-area-inset-bottom) 14px}
  .row{display:flex;align-items:center;justify-content:space-between;gap:10px}
  .pill{background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.16);padding:8px 12px;border-radius:12px;backdrop-filter:blur(6px);font-weight:800;letter-spacing:.3px}
  .btn{pointer-events:auto;user-select:none;cursor:pointer;background:var(--teal);color:#081018;border:none;font-weight:900;padding:10px 14px;border-radius:12px;box-shadow:0 6px 0 rgba(0,0,0,.35);transition:transform .06s ease,filter .2s ease}
  .btn:active{transform:translateY(2px);box-shadow:0 4px 0 rgba(0,0,0,.35)}
  .btn.alt{background:#fff;color:#111}
  .btn.gold{background:var(--gold);color:#111}
  /* Overlays */
  #overlay{position:fixed;inset:0;display:none;place-items:center;background:rgba(0,0,0,.38);backdrop-filter:blur(6px);z-index:5}
  #overlay.show{display:grid}
  .card{width:min(560px,92vw);background:linear-gradient(180deg,var(--glass),rgba(255,255,255,.05));border:1px solid rgba(255,255,255,.16);border-radius:18px;padding:20px;text-align:center}
  h1{margin:.2rem 0 0;font-size:1.6rem}
  p{margin:.35rem 0;opacity:.92}
  .hint{font-size:.9rem;opacity:.85}
  .actions{display:flex;gap:10px;justify-content:center;margin-top:12px}
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<!-- HUD -->
<div id="hud">
  <div class="row" style="padding:10px">
    <div class="pill" id="score">Score: 0</div>
    <div class="row" style="gap:8px">
      <div class="pill" id="coins">Coins: 0</div>
      <div class="pill" id="best">Best: 0</div>
      <button id="muteBtn" class="btn alt">Mute</button>
      <button id="pauseBtn" class="btn">Pause</button>
    </div>
  </div>
  <div class="row" style="padding:10px">
    <a class="btn gold" href="/" title="Back to site">‚Üê Back</a>
    <button id="restartBtn" class="btn">Restart</button>
  </div>
</div>

<!-- Start / Game Over overlay -->
<div id="overlay" class="show" role="dialog" aria-modal="true">
  <div class="card">
    <h1 id="title">$NARPE ‚Äî Swim & Dodge</h1>
    <p id="subtitle">Tap / Space / ‚Üë to swim. Wide lanes, varied patterns, collect coins.</p>
    <p class="hint">Mobile: tap anywhere ¬∑ Desktop: Space or ‚Üë ¬∑ M to mute</p>
    <div class="actions">
      <button id="playBtn" class="btn">Play</button>
      <button id="howBtn" class="btn alt">How to</button>
    </div>
    <div class="actions" id="shareWrap" style="display:none">
      <button id="shareBtn" class="btn gold">Share score on X</button>
    </div>
  </div>
</div>

<script>
(()=>{
/* ===== Canvas & DPI ===== */
const dpr = Math.max(1, Math.min(2, devicePixelRatio||1));
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
function resize(){ canvas.width=Math.floor(innerWidth*dpr); canvas.height=Math.floor(innerHeight*dpr); ctx.setTransform(dpr,0,0,dpr,0,0); }
addEventListener('resize', resize, {passive:true}); resize();

/* ===== Optional Narpe image ===== */
const narpeImg = new Image(); let narpeReady=false;
narpeImg.onload=()=>narpeReady=true; narpeImg.onerror=()=>narpeReady=false;
narpeImg.src='narpe.png'; // optional; fallback drawing if missing

/* ===== Audio (simple WebAudio tones) ===== */
let audioCtx, masterGain; let muted=false;
function initAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  masterGain = audioCtx.createGain(); masterGain.gain.value = 0.7; masterGain.connect(audioCtx.destination);
  startMusic();
}
function startMusic(){
  const osc = audioCtx.createOscillator(), g = audioCtx.createGain();
  osc.type='sine'; g.gain.value=0; osc.connect(g).connect(masterGain); osc.start();
  const notes=[261.63,329.63,392.00,329.63,293.66,261.63,196.00,261.63]; // simple loop
  let i=0;
  setInterval(()=>{ if(!audioCtx||muted) return;
    const t=audioCtx.currentTime;
    osc.frequency.setTargetAtTime(notes[i%notes.length], t, 0.02);
    g.gain.cancelScheduledValues(t); g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.08, t+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.35);
    i++;
  }, 420);
}
function sfxCoin(){ if(!audioCtx||muted) return;
  const o=audioCtx.createOscillator(), g=audioCtx.createGain();
  o.type='triangle'; o.frequency.value=900; g.gain.value=0; o.connect(g).connect(masterGain);
  const t=audioCtx.currentTime; o.start(t);
  o.frequency.exponentialRampToValueAtTime(1500, t+0.08);
  g.gain.linearRampToValueAtTime(0.18, t+0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, t+0.22);
  o.stop(t+0.24);
}
function sfxLose(){ if(!audioCtx||muted) return;
  const o=audioCtx.createOscillator(), g=audioCtx.createGain();
  o.type='sawtooth'; o.frequency.value=420; g.gain.value=0; o.connect(g).connect(masterGain);
  const t=audioCtx.currentTime; o.start(t);
  o.frequency.exponentialRampToValueAtTime(120, t+0.4);
  g.gain.linearRampToValueAtTime(0.22, t+0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, t+0.5);
  o.stop(t+0.52);
}

/* ===== Game State ===== */
let running=false, paused=false, over=false;
let tLast=0, time=0, spawnTimer=0, patternTimer=0, currentPattern='straight';
let score=0, coins=0, best=Number(localStorage.getItem('narpe_best')||0);
let speed=150, speedMult=1.0; const SPEED_RAMP=0.012; // very gradual
const HUD={
  score:document.getElementById('score'),
  coins:document.getElementById('coins'),
  best:document.getElementById('best'),
  pauseBtn:document.getElementById('pauseBtn'),
  restartBtn:document.getElementById('restartBtn'),
  muteBtn:document.getElementById('muteBtn'),
  overlay:document.getElementById('overlay'),
  title:document.getElementById('title'),
  subtitle:document.getElementById('subtitle'),
  playBtn:document.getElementById('playBtn'),
  howBtn:document.getElementById('howBtn'),
  shareWrap:document.getElementById('shareWrap'),
  shareBtn:document.getElementById('shareBtn'),
};
HUD.best.textContent='Best: '+best;

const narpe={ x: innerWidth*0.24, y: innerHeight*0.5, vy:0, r:30, tilt:0 }; // smaller r = more forgiving
const OBS=[]; const COINS=[];
let laneY=innerHeight*0.5, laneTarget=laneY;

/* ===== Helpers ===== */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const rnd=(a,b)=>a+Math.random()*(b-a);
function circleRectHit(cx,cy,cr, rx,ry,rw,rh, margin=10){
  // shrink rect by margin to avoid phantom hits
  const x1=rx+margin, y1=ry+margin, x2=rx+rw-margin, y2=ry+rh-margin;
  const nx=clamp(cx,x1,x2), ny=clamp(cy,y1,y2);
  const dx=cx-nx, dy=cy-ny; return dx*dx+dy*dy < cr*cr;
}
function circleHit(ax,ay,ar, bx,by,br){ const dx=ax-bx, dy=ay-by; return (dx*dx+dy*dy) < (ar+br)*(ar+br); }

/* ===== Input ===== */
function swim(){ if(!running){ start(); return; } if(over||paused) return; narpe.vy=-440; }
addEventListener('keydown',e=>{
  if([' ','ArrowUp','Spacebar'].includes(e.key)){ e.preventDefault(); swim(); }
  if(e.key==='p') togglePause(); if(e.key==='m') toggleMute();
});
addEventListener('pointerdown',()=>swim(),{passive:true});
HUD.playBtn.onclick=()=>start();
HUD.howBtn.onclick=()=>HUD.subtitle.textContent='Swim with tap/Space. Wide lanes. Score by passing gates; coins +5. Game speeds up gradually.';
HUD.pauseBtn.onclick=()=>togglePause();
HUD.restartBtn.onclick=()=>reset(true);
HUD.muteBtn.onclick=()=>toggleMute();
HUD.shareBtn.onclick=()=>{
  const text=encodeURIComponent(`I scored ${score} (${coins} coins) in $NARPE Swim & Dodge! üåäü¶Ñ #NARPE #Abstract`);
  const url=encodeURIComponent(location.origin);
  window.open(`https://twitter.com/intent/tweet?text=${text}&url=${url}`,'_blank');
};
function togglePause(){ if(!running||over) return; paused=!paused; HUD.pauseBtn.textContent=paused?'Resume':'Pause'; showOverlay(paused, paused?'Paused':'', paused?'Tap / Space / ‚Üë to continue.':''); }
function toggleMute(){ muted=!muted; HUD.muteBtn.textContent=muted?'Unmute':'Mute'; if(audioCtx) masterGain.gain.value = muted ? 0 : 0.7; }

/* ===== Flow ===== */
function showOverlay(show,title,subtitle){
  HUD.overlay.classList.toggle('show', !!show);
  if(title) HUD.title.textContent=title;
  if(subtitle) HUD.subtitle.textContent=subtitle;
  HUD.shareWrap.style.display=(show&&over)?'flex':'none';
}
function start(){ reset(false); running=true; paused=false; over=false; tLast=performance.now(); showOverlay(false); initAudio(); requestAnimationFrame(loop); }
function reset(hard){
  score=0; coins=0; speed=150; speedMult=1.0; spawnTimer=0; patternTimer=0; currentPattern='straight';
  HUD.score.textContent='Score: 0'; HUD.coins.textContent='Coins: 0';
  narpe.x=innerWidth*0.24; narpe.y=innerHeight*0.5; narpe.vy=0; narpe.tilt=0;
  laneY=innerHeight*0.5; laneTarget=laneY;
  OBS.length=0; COINS.length=0;
  if(hard){ running=false; over=false; paused=false; showOverlay(true,'$NARPE ‚Äî Swim & Dodge','Tap / Space / ‚Üë to swim. Wide lanes, varied patterns, coins to collect.'); }
}
function end(){
  over=true; running=false; paused=false; sfxLose();
  if(score>best){ best=score; localStorage.setItem('narpe_best',best); HUD.best.textContent='Best: '+best; }
  showOverlay(true,'Game Over',`Score: ${score} ‚Ä¢ Best: ${best} ‚Ä¢ Coins: ${coins}`);
  HUD.shareWrap.style.display='flex';
}

/* ===== Patterns & Spawning ===== */
function pickPattern(){
  const patterns=['straight','gentleWave','rising','falling','zigzag'];
  currentPattern = patterns[Math.floor(Math.random()*patterns.length)];
  patternTimer = 4 + Math.random()*4; // seconds until next change
}
function updateLane(dt){
  patternTimer -= dt; if(patternTimer<=0) pickPattern();
  const h=innerHeight, bandTop=h*0.26, bandBot=h*0.74; // safe vertical band
  switch(currentPattern){
    case 'straight': laneTarget += rnd(-40,40); break;
    case 'gentleWave': laneTarget += Math.sin(time*2.0)*30 + rnd(-10,10); break;
    case 'rising': laneTarget -= 60*dt* (1+Math.random()*0.3); break;
    case 'falling': laneTarget += 60*dt* (1+Math.random()*0.3); break;
    case 'zigzag': laneTarget += (Math.sin(time*3.2)>0? 120:-120)*dt; break;
  }
  laneTarget = clamp(laneTarget, bandTop, bandBot);
  // smooth follow
  laneY += (laneTarget - laneY) * Math.min(1, dt*3.5);
}
function spawn(){
  const h=innerHeight;
  // WIDE gap: 32‚Äì36% of screen height, never less than 220px
  const GAP = Math.max(220, h * (0.32 + Math.random()*0.04));
  updateLane(0); // ensure laneY current
  const yMid = laneY;
  const v = speed * speedMult;

  // choose obstacle mix; at most 1 mine per pair for fairness
  const topIsMine = Math.random()<0.25;
  const botIsMine = !topIsMine && Math.random()<0.25;

  // ICE rectangles
  if(!topIsMine)  OBS.push({shape:'rect', x: innerWidth+60, y: yMid-GAP/2-180, w:64, h:280, vx:-v, passed:false});
  if(!botIsMine)  OBS.push({shape:'rect', x: innerWidth+60, y: yMid+GAP/2,     w:64, h:280, vx:-v, passed:false});

  // MINE circles (true circle collision, smaller radius)
  if(topIsMine)   OBS.push({shape:'circle', x: innerWidth+92, y: yMid-GAP/2-90,  r:22, vx:-v, passed:false});
  if(botIsMine)   OBS.push({shape:'circle', x: innerWidth+92, y: yMid+GAP/2+90,  r:22, vx:-v, passed:false});

  // coin in/near the lane
  if(Math.random()<0.85){
    COINS.push({x: innerWidth+ 60 + rnd(140,220), y: yMid + rnd(-GAP/3, GAP/3), r:12, vx:-v, got:false});
  }

  // spawn cadence proportional to speed so spacing feels consistent
  spawnTimer = (1.65) * (150 / speed);
}

/* ===== Drawing ===== */
function drawBG(tm){
  const w=innerWidth,h=innerHeight;
  ctx.clearRect(0,0,w,h);
  const g=ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0,'#0a2a6b'); g.addColorStop(1,'#041632');
  ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
  for(let i=0;i<5;i++){
    const x=(tm*0.02 + i*220)%(w+220)-220;
    ctx.globalAlpha=.06; ctx.fillStyle='#7fd1ff';
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x+140,0); ctx.lineTo(x+40,h); ctx.lineTo(x-100,h); ctx.closePath(); ctx.fill();
  }
  ctx.globalAlpha=1;
  for(let i=0;i<18;i++){
    const bx=(tm*0.12 + i*(w/18))%(w+80)-40;
    const by=(tm*0.06 + i*40)%(h+40)-20;
    ctx.globalAlpha=.35; ctx.fillStyle='#b8f0ff';
    ctx.beginPath(); ctx.arc(bx,h-by,3+(i%3),0,Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha=1;
}
function drawNarpe(x,y,tilt){
  if(narpeReady){
    const s=96; ctx.save(); ctx.translate(x,y); ctx.rotate(tilt*0.04);
    ctx.drawImage(narpeImg,-s*0.6,-s*0.6,s*1.2,s*1.2); ctx.restore();
  }else{
    ctx.save(); ctx.translate(x,y); ctx.rotate(tilt*0.04);
    ctx.fillStyle='#bfe7ff'; ctx.beginPath(); ctx.ellipse(0,0,44,34,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#e8f7ff'; ctx.beginPath(); ctx.ellipse(0,8,26,20,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#bfe7ff'; ctx.beginPath(); ctx.moveTo(-40,8); ctx.quadraticCurveTo(-64,0,-44,-8); ctx.quadraticCurveTo(-28,0,-40,8); ctx.fill();
    ctx.strokeStyle='#503200'; ctx.lineWidth=2; ctx.fillStyle='#ffd75e';
    ctx.beginPath(); ctx.moveTo(22,-18); ctx.lineTo(58,-28); ctx.lineTo(20,-8); ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.fillStyle='#fff'; ctx.beginPath(); ctx.ellipse(8,-4,12,10,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(12,-4,4,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#ed6a5a'; ctx.lineWidth=4; ctx.beginPath(); ctx.arc(6,10,12,.2*Math.PI,.9*Math.PI); ctx.stroke();
    ctx.restore();
  }
}
function drawObstacle(o){
  ctx.save(); 
  if(o.shape==='rect'){
    ctx.translate(o.x,o.y);
    ctx.fillStyle='#9fe3ff'; ctx.strokeStyle='#4aa7c7'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(o.w,10); ctx.lineTo(o.w,o.h); ctx.lineTo(0,o.h); ctx.closePath(); ctx.fill(); ctx.stroke();
  }else{ // circle mine
    ctx.translate(o.x,o.y);
    ctx.fillStyle='#5c6b7a'; ctx.beginPath(); ctx.arc(0,0,o.r,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#7f8fa0';
    for(let k=0;k<6;k++){ const a=k*Math.PI/3, R=o.r+10; ctx.beginPath(); ctx.arc(Math.cos(a)*R, Math.sin(a)*R, 4, 0, Math.PI*2); ctx.fill(); }
  }
  ctx.restore();
}
function drawCoin(c){
  ctx.save(); ctx.translate(c.x,c.y);
  const r=c.r, g=ctx.createRadialGradient(0,0,2,0,0,r);
  g.addColorStop(0,'#fff5cc'); g.addColorStop(1,'#ffd75e');
  ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='rgba(0,0,0,.35)'; ctx.lineWidth=2; ctx.stroke();
  ctx.restore();
}

/* ===== Loop ===== */
function loop(now){
  if(!running) return;
  const dt=Math.min(0.04,(now-tLast)/1000); tLast=now; time+=dt;

  if(!paused && !over){
    // speed up gradually (not tighter gaps)
    speedMult += SPEED_RAMP * dt;
    const v = speed * speedMult;

    // physics
    const G=1080;
    narpe.vy += G*dt; narpe.vy = clamp(narpe.vy, -520, 700);
    narpe.y += narpe.vy*dt; narpe.y = clamp(narpe.y, 30, innerHeight-30);
    narpe.tilt = narpe.vy/200;

    // spawn cadence follows speed for consistent spacing
    spawnTimer -= dt;
    if(spawnTimer<=0){ updateLane(dt); spawn(); }

    // move
    for(const o of OBS){ o.vx=-v; o.x += o.vx*dt; }
    for(const c of COINS){ c.vx=-v; c.x += c.vx*dt; }

    // collisions & scoring
    for(const o of OBS){
      let hit=false;
      if(o.shape==='rect'){ hit = circleRectHit(narpe.x,narpe.y,narpe.r, o.x,o.y,o.w,o.h, 12); }
      else { // circle mine: smaller effective radius => no phantom hits
        hit = circleHit(narpe.x,narpe.y, narpe.r*0.8, o.x,o.y, o.r*0.9);
      }
      if(hit){ end(); return; }
      if(!o.passed && o.x + (o.w||o.r*2) < narpe.x){ o.passed=true; score+=1; HUD.score.textContent='Score: '+score; }
    }
    for(const c of COINS){
      if(!c.got && circleHit(narpe.x,narpe.y,narpe.r*0.75, c.x,c.y,c.r)){
        c.got=true; coins++; score+=5; HUD.coins.textContent='Coins: '+coins; HUD.score.textContent='Score: '+score; sfxCoin();
      }
    }

    // cleanup
    while(OBS.length && (OBS[0].x + (OBS[0].w||OBS[0].r*2)) < -100) OBS.shift();
    while(COINS.length && COINS[0].x < -100) COINS.shift();
  }

  // draw
  drawBG(time*60);
  for(const o of OBS) drawObstacle(o);
  for(const c of COINS) if(!c.got) drawCoin(c);
  drawNarpe(narpe.x,narpe.y,narpe.tilt);

  requestAnimationFrame(loop);
}

/* ===== Start ===== */
function showStart(){
  HUD.title.textContent='$NARPE ‚Äî Swim & Dodge';
  HUD.subtitle.textContent='Tap / Space / ‚Üë to swim. Wide lanes, varied patterns, coins to collect.';
  HUD.shareWrap.style.display='none';
  showOverlay(true);
}
showStart();
})();
</script>
</body>
</html>
